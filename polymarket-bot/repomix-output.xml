This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: *.jsonl, *.log, venv/, __pycache__/, *.pkl, paper_trades_*.jsonl
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
.gitignore
auto_redeem.py
btc_15m_bot_v3.py
check_account.py
check_balance.py
check_prev_market.py
fetch_history.py
gemini_trader.py
inspect_market.py
polymarket-bot.service
README.md
repomix.config.json
test_connection.py
test_order.py
train_ml.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# Polymarket Bot Configuration
# Copy this to .env and fill in your values

# Your wallet private key (WITHOUT 0x prefix)
PRIVATE_KEY=your_private_key_here

# Funder address (the address that holds your USDC on Polymarket)
# If using EOA directly, this is usually the same as your wallet address
FUNDER_ADDRESS=your_funder_address_here

# Risk Management
MAX_POSITION_SIZE=10.0      # Max USDC per trade
MAX_DAILY_LOSS=50.0         # Stop trading if daily loss exceeds this
MIN_EDGE=0.02               # Minimum edge (2%) to take a trade

# Strategy
STRATEGY=momentum           # momentum, mean_reversion, or random_baseline
CONFIDENCE_THRESHOLD=0.55   # Minimum confidence to trade (0.5-1.0)

# Monitoring
TELEGRAM_NOTIFY=true        # Send trade notifications
LOG_LEVEL=INFO
</file>

<file path=".gitignore">
.env
</file>

<file path="auto_redeem.py">
#!/usr/bin/env python3
"""
è‡ªåŠ¨èµå›å·²ç»“ç®—å¸‚åœºçš„ä»“ä½
æ£€æŸ¥æŒä»“ï¼Œå¦‚æœå¸‚åœºå·²ç»“ç®—ä¸”æŒæœ‰èƒœå‡ºæ–¹ï¼Œè‡ªåŠ¨èµå› USDC
"""
import os
import requests
from dotenv import load_dotenv
from py_clob_client.client import ClobClient
load_dotenv()
CLOB_HOST = "https://clob.polymarket.com"
DATA_API = "https://data-api.polymarket.com"
GAMMA_API = "https://gamma-api.polymarket.com"
CHAIN_ID = 137
def get_positions(address: str) -> list:
    """è·å–æ‰€æœ‰æŒä»“"""
    resp = requests.get(
        f"{DATA_API}/positions",
        params={"user": address.lower()},
        timeout=15
    )
    return resp.json()
def get_market_info(condition_id: str) -> dict:
    """è·å–å¸‚åœºè¯¦ç»†ä¿¡æ¯"""
    try:
        resp = requests.get(
            f"{GAMMA_API}/markets",
            params={"conditionId": condition_id},
            timeout=10
        )
        markets = resp.json()
        return markets[0] if markets else {}
    except:
        return {}
def check_redeemable(client: ClobClient, positions: list) -> list:
    """æ£€æŸ¥å“ªäº›ä»“ä½å¯ä»¥èµå›"""
    redeemable = []
    for pos in positions:
        condition_id = pos.get('conditionId', '')
        if not condition_id:
            continue
        # è·å–å¸‚åœºä¿¡æ¯
        market = get_market_info(condition_id)
        if not market:
            continue
        # æ£€æŸ¥æ˜¯å¦å·²ç»“ç®—
        if not market.get('closed', False):
            continue
        winning_outcome = market.get('winningOutcome', '').lower()
        if not winning_outcome:
            continue
        # æ£€æŸ¥æ˜¯å¦æŒæœ‰èƒœå‡ºæ–¹
        outcome = pos.get('outcome', '').lower()
        size = float(pos.get('size', 0))
        if outcome == winning_outcome and size > 0:
            redeemable.append({
                'question': market.get('question', 'Unknown'),
                'condition_id': condition_id,
                'outcome': outcome,
                'size': size,
                'value': size  # èƒœå‡ºæ–¹æ¯ share ä»·å€¼ $1
            })
    return redeemable
def redeem_positions(client: ClobClient, redeemable: list) -> list:
    """èµå›ä»“ä½ï¼ˆè¿”å›ç»“æœåˆ—è¡¨ï¼‰"""
    results = []
    for pos in redeemable:
        try:
            # Polymarket çš„èµå›æ˜¯è‡ªåŠ¨çš„ï¼Œå½“å¸‚åœºç»“ç®—åï¼Œ
            # èƒœå‡ºçš„ token ä¼šè‡ªåŠ¨å˜æˆ USDC
            # ä½†å¦‚æœéœ€è¦æ‰‹åŠ¨è§¦å‘ï¼Œå¯ä»¥é€šè¿‡ CTF åˆçº¦
            # ç›®å‰ py-clob-client ä¸ç›´æ¥æ”¯æŒ redeem
            # è¿™é‡Œè®°å½•å¯èµå›çš„ä»“ä½
            results.append({
                'status': 'pending',
                'question': pos['question'][:50],
                'outcome': pos['outcome'],
                'value': pos['value']
            })
            print(f"ğŸ’° å¯èµå›: {pos['question'][:50]}")
            print(f"   {pos['outcome'].upper()} x {pos['size']:.4f} = ${pos['value']:.2f}")
        except Exception as e:
            results.append({
                'status': 'error',
                'error': str(e)
            })
    return results
def main():
    print("=" * 60)
    print("Polymarket è‡ªåŠ¨èµå›æ£€æŸ¥")
    print("=" * 60)
    private_key = os.getenv("PRIVATE_KEY")
    funder = os.getenv("FUNDER_ADDRESS")
    if not private_key or not funder:
        print("é”™è¯¯: éœ€è¦è®¾ç½® PRIVATE_KEY å’Œ FUNDER_ADDRESS")
        return
    print(f"\né’±åŒ…: {funder[:10]}...{funder[-6:]}")
    # åˆå§‹åŒ–å®¢æˆ·ç«¯
    client = ClobClient(
        CLOB_HOST,
        key=private_key,
        chain_id=CHAIN_ID,
        signature_type=2,
        funder=funder
    )
    client.set_api_creds(client.create_or_derive_api_creds())
    # è·å–æŒä»“
    print("\nè·å–æŒä»“...")
    positions = get_positions(funder)
    print(f"æ€»æŒä»“æ•°: {len(positions)}")
    if not positions:
        print("æ²¡æœ‰æŒä»“")
        return
    # æ£€æŸ¥å¯èµå›
    print("\næ£€æŸ¥å¯èµå›ä»“ä½...")
    redeemable = check_redeemable(client, positions)
    if not redeemable:
        print("æ²¡æœ‰å¯èµå›çš„ä»“ä½")
        print("\nå½“å‰æŒä»“çŠ¶æ€:")
        for pos in positions:
            outcome = pos.get('outcome', 'N/A')
            size = float(pos.get('size', 0))
            print(f"  â€¢ {size:.4f} {outcome} (å¸‚åœºæœªç»“ç®—)")
        return
    # æ˜¾ç¤ºå¯èµå›
    print(f"\nå‘ç° {len(redeemable)} ä¸ªå¯èµå›ä»“ä½:")
    total_value = 0
    for pos in redeemable:
        print(f"  ğŸ’° {pos['question'][:40]}...")
        print(f"     {pos['outcome'].upper()} x {pos['size']:.4f} = ${pos['value']:.2f}")
        total_value += pos['value']
    print(f"\næ€»å¯èµå›: ${total_value:.2f}")
    # æ³¨æ„ï¼šå®é™…èµå›éœ€è¦è°ƒç”¨ CTF åˆçº¦
    print("\næ³¨æ„: Polymarket çš„å·²ç»“ç®—ä»“ä½é€šå¸¸ä¼šè‡ªåŠ¨è½¬ä¸º USDC")
    print("å¦‚æœæ²¡æœ‰è‡ªåŠ¨è½¬æ¢ï¼Œè¯·åœ¨ polymarket.com æ‰‹åŠ¨èµå›")
if __name__ == "__main__":
    main()
</file>

<file path="btc_15m_bot_v3.py">
#!/usr/bin/env python3
"""
Polymarket BTC 15-minute Trading Bot v3 (Smart Probability)
- Retrieves 'Strike Price' (Open price of the 15m candle) from Binance.
- Calculates theoretical probability based on distance to strike and time remaining.
- Trades only when market price deviates significantly from fair value.
"""
import os
import sys
import json
import time
import math
import asyncio
import logging
from datetime import datetime, timezone, timedelta
from typing import Optional, Dict, List, Tuple
from dataclasses import dataclass, field
import statistics
import requests
import websockets
from dotenv import load_dotenv
from py_clob_client.client import ClobClient
from py_clob_client.clob_types import OrderArgs, OrderType
from py_clob_client.order_builder.constants import BUY
# Load environment
load_dotenv()
from logging.handlers import RotatingFileHandler
# Setup logging
logging.basicConfig(
    level=getattr(logging, os.getenv('LOG_LEVEL', 'INFO')),
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        RotatingFileHandler('bot.log', maxBytes=5*1024*1024, backupCount=3) # 5MB limit, keep 3 backups
    ]
)
logger = logging.getLogger(__name__)
# Constants
CLOB_HOST = "https://clob.polymarket.com"
GAMMA_API = "https://gamma-api.polymarket.com"
WS_URL = "wss://ws-subscriptions-clob.polymarket.com/ws/market"
CHAIN_ID = 137
@dataclass
class OrderBook:
    """Real-time order book"""
    asset_id: str
    best_bid: float = 0.0
    best_ask: float = 1.0
    def update(self, data: dict):
        if data.get("event_type") == "price_change":
            for change in data.get("price_changes", []):
                if change.get("asset_id") == self.asset_id:
                    self.best_bid = float(change.get("best_bid", 0) or 0)
                    self.best_ask = float(change.get("best_ask", 1) or 1)
        elif data.get("event_type") == "book":
             bids = data.get("bids", [])
             asks = data.get("asks", [])
             if bids: self.best_bid = float(bids[0]["price"])
             if asks: self.best_ask = float(asks[0]["price"])
@dataclass
class Market15m:
    condition_id: str
    question: str
    token_id_up: str
    token_id_down: str
    start_time: datetime
    end_time: datetime
    slug: str
    # Real-time data
    book_up: OrderBook = None
    book_down: OrderBook = None
    strike_price: Optional[float] = None  # The BTC price at start_time
    def __post_init__(self):
        self.book_up = OrderBook(self.token_id_up)
        self.book_down = OrderBook(self.token_id_down)
    @property
    def time_remaining(self) -> timedelta:
        return self.end_time - datetime.now(timezone.utc)
    @property
    def is_active(self) -> bool:
        return self.time_remaining.total_seconds() > 30
    @property
    def up_price(self) -> float:
        return self.book_up.best_ask if self.book_up.best_ask > 0 else 0.5
    @property
    def down_price(self) -> float:
        return self.book_down.best_ask if self.book_down.best_ask > 0 else 0.5
class BinanceData:
    """Helper to fetch Binance data"""
    @staticmethod
    def get_candle_open(timestamp_ms: int) -> Optional[float]:
        """Get the Open price of the candle starting at timestamp"""
        try:
            # Kline interval 1m
            url = "https://api.binance.com/api/v3/klines"
            params = {
                "symbol": "BTCUSDT",
                "interval": "1m",
                "startTime": timestamp_ms,
                "limit": 1
            }
            logger.info(f"Fetching Binance Candle for TS: {timestamp_ms} ({datetime.fromtimestamp(timestamp_ms/1000, timezone.utc)})")
            resp = requests.get(url, params=params, timeout=5)
            data = resp.json()
            if data and len(data) > 0:
                open_price = float(data[0][1])
                logger.info(f"Binance Open Price: {open_price}")
                return open_price
            return None
        except Exception as e:
            logger.error(f"Binance API error: {e}")
            return None
    @staticmethod
    def get_current_price() -> Optional[float]:
        try:
            resp = requests.get("https://api.binance.com/api/v3/ticker/price?symbol=BTCUSDT", timeout=5)
            return float(resp.json()["price"])
        except:
            return None
class MarketCycleManager:
    """Manages finding active markets"""
    def __init__(self):
        self.past_markets = []
    def fetch_market(self) -> Optional[Market15m]:
        try:
            # Calculate current 15m cycle strictly by time
            now = datetime.now(timezone.utc)
            current_ts = int(now.timestamp())
            current_15m_ts = (current_ts // 900) * 900
            # Use calculated timestamp for slug AND start_time
            slug = f"btc-updown-15m-{current_15m_ts}"
            # Start time is strictly the 15m boundary
            start_time = datetime.fromtimestamp(current_15m_ts, timezone.utc)
            # End time is +15m
            end_time = start_time + timedelta(minutes=15)
            resp = requests.get(f"{GAMMA_API}/events?slug={slug}", timeout=10)
            events = resp.json()
            if not events:
                # Try next slot if we are close to end? No, stick to current.
                return None
            event = events[0]
            if event.get("closed"): return None
            markets = event.get("markets", [])
            if not markets or not markets[0].get("acceptingOrders"): return None
            m_data = markets[0]
            token_ids = json.loads(m_data.get("clobTokenIds", "[]"))
            outcomes = json.loads(m_data.get("outcomes", '["Up", "Down"]'))
            if outcomes[0].lower() == "up":
                t_up, t_down = token_ids[0], token_ids[1]
            else:
                t_up, t_down = token_ids[1], token_ids[0]
            return Market15m(
                condition_id=m_data.get("conditionId"),
                question=m_data.get("question", event.get("title")),
                token_id_up=t_up,
                token_id_down=t_down,
                start_time=start_time, # Use calculated strict time
                end_time=end_time,     # Use calculated strict time
                slug=event.get("slug")
            )
        except Exception as e:
            logger.error(f"Fetch market error: {e}")
            return None
class ProbabilityStrategy:
    """Calculates Fair Value based on Normal Distribution"""
    def __init__(self):
        self.volatility_per_min = 25.0  # Conservative BTC vol/min in USD (approx)
        # TODO: Calculate dynamic vol
    def calculate_prob_up(self, current_price: float, strike_price: float, minutes_left: float) -> float:
        """
        Calculate Probability(Final Price > Strike)
        Assumes Brownian motion (Normal distribution of price changes).
        """
        if minutes_left <= 0:
            return 1.0 if current_price >= strike_price else 0.0
        # Standard Deviation for the remaining time
        # sigma_t = sigma_1min * sqrt(t)
        sigma_t = self.volatility_per_min * math.sqrt(minutes_left)
        if sigma_t == 0:
            return 1.0 if current_price >= strike_price else 0.0
        # Z-score: How many std devs is current price away from strike?
        # If current > strike, Z is positive.
        z_score = (current_price - strike_price) / sigma_t
        # Cumulative Distribution Function (CDF)
        prob_up = 0.5 * (1 + math.erf(z_score / math.sqrt(2)))
        return prob_up
import joblib
# ... imports ...
class PolymarketBotV3:
    def __init__(self):
        self.running = True
        self.paper_trade = True
        self.positions = []
        self.cycle_manager = MarketCycleManager()
        self.strategy = ProbabilityStrategy()
        # Trading Parameters
        self.stop_loss_pct = 0.25      # 25% Stop Loss
        self.fee_pct = 0.001           # 0.1% Fee estimate
        self.safety_margin_pct = 0.0005 # $50 on $100k BTC (tight)
        self.min_edge = 0.10           # 10% Probability Edge required
        self.performance_history = [] 
        # Load ML Model
        self.ml_model = None
        if os.path.exists("polymarket-bot/ml_model_v1.pkl"):
            try:
                self.ml_model = joblib.load("polymarket-bot/ml_model_v1.pkl")
                logger.info("ğŸ§  ML Model Loaded: Random Forest v1")
            except Exception as e:
                logger.error(f"Failed to load ML model: {e}")
    # ... existing analyze_performance ...
    async def trade_loop(self, market: Market15m):
        # ... setup ...
        while self.running and market.is_active:
            # 1. Get Data
            current_btc = BinanceData.get_current_price()
            if not current_btc:
                await asyncio.sleep(2)
                continue
            time_left = market.time_remaining.total_seconds() / 60.0 # minutes
            # 2. Calculate Fair Value (Probabilistic)
            prob_up = self.strategy.calculate_prob_up(current_btc, market.strike_price, time_left)
            prob_down = 1.0 - prob_up
            # 3. AI Prediction (Machine Learning)
            ai_confidence = 0.0
            if self.ml_model:
                try:
                    # Features: ['entry_price', 'direction_code', 'hour']
                    # We simulate both directions to see which one AI likes
                    # Note: Our training data used simple features. We need to match feature_engineering in train_ml.py
                    # Actually, let's simplify. If AI predicts UP wins, we boost prob_up.
                    # Current hour
                    hour = datetime.now(timezone.utc).hour
                    # Predict UP
                    # Features must match training: [entry_price, direction_code, hour]
                    # We don't have entry_price yet, use current market price
                    X_up = [[market.up_price, 1, hour]]
                    X_down = [[market.down_price, 0, hour]]
                    # Predict Class (1=WIN, 0=LOSS)
                    pred_up = self.ml_model.predict(X_up)[0]
                    pred_down = self.ml_model.predict(X_down)[0]
                    if pred_up == 1: 
                        prob_up += 0.05 # Boost UP probability by 5%
                        logger.debug("ğŸ§  AI likes UP")
                    if pred_down == 1: 
                        prob_down += 0.05 # Boost DOWN
                        logger.debug("ğŸ§  AI likes DOWN")
                except Exception as e:
                    pass # Ignore ML errors, fallback to math
            # 4. Decision (with AI boost)
            # ... rest of decision logic ...
    def analyze_performance(self):
        """Self-Correction: Adjust parameters based on recent performance"""
        try:
            if not os.path.exists("paper_trades.jsonl"): return
            # File Size Protection: If > 10MB, rotate it
            if os.path.getsize("paper_trades.jsonl") > 10 * 1024 * 1024:
                logger.info("ç»´æŠ¤: paper_trades.jsonl è¿‡å¤§ï¼Œè¿›è¡Œå½’æ¡£æ¸…ç†...")
                os.rename("paper_trades.jsonl", f"paper_trades_{int(time.time())}.jsonl")
            wins = 0
            losses = 0
            gross_profit = 0.0
            gross_loss = 0.0
            recent_trades = []
            with open("paper_trades.jsonl", "r") as f:
                for line in f:
                    try:
                        trade = json.loads(line)
                        if "pnl" in trade: # Closed trade
                            recent_trades.append(trade)
                    except: pass
            # Analyze last 20 closed trades for statistical significance
            recent_trades = recent_trades[-20:]
            if not recent_trades: return
            for t in recent_trades:
                pnl = float(t["pnl"])
                if pnl > 0: 
                    wins += 1
                    gross_profit += pnl
                else: 
                    losses += 1
                    gross_loss += abs(pnl)
            total = wins + losses
            if total == 0: return
            win_rate = wins / total
            profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
            avg_win = gross_profit / wins if wins > 0 else 0
            avg_loss = gross_loss / losses if losses > 0 else 0
            # Log Core Metrics for User
            logger.info(f"ğŸ“Š ä¸šç»©åˆ†æ (æœ€è¿‘{total}ç¬”):")
            logger.info(f"   èƒœç‡: {win_rate:.0%} | ç›ˆäºæ¯” (Profit Factor): {profit_factor:.2f}")
            logger.info(f"   å¹³å‡ç›ˆåˆ©: +{avg_win:.1%} | å¹³å‡äºæŸ: -{avg_loss:.1%}")
            # Auto-Adjustment Logic (Optimizing for Profit Factor > 1.5)
            old_margin = self.safety_margin_pct
            if profit_factor < 1.0 or win_rate < 0.4:
                # Losing money: Tighten significantly
                self.safety_margin_pct = min(0.002, self.safety_margin_pct * 1.2)
                self.min_edge = min(0.25, self.min_edge + 0.02)
                logger.info(f"ğŸ“‰ è¡¨ç°ä¸ä½³ (PF < 1.0). æ”¶ç´§é£æ§: Margin -> {self.safety_margin_pct:.2%}, Edge -> {self.min_edge:.2%}")
            elif profit_factor > 2.0 and win_rate > 0.6:
                # Making good money: Optimize for volume
                self.safety_margin_pct = max(0.0002, self.safety_margin_pct * 0.9)
                self.min_edge = max(0.05, self.min_edge - 0.01)
                logger.info(f"ğŸ“ˆ è¡¨ç°ä¼˜å¼‚ (PF > 2.0). é‡Šæ”¾æµåŠ¨æ€§: Margin -> {self.safety_margin_pct:.2%}, Edge -> {self.min_edge:.2%}")
        except Exception as e:
            logger.error(f"Auto-tune error: {e}")
    async def run(self):
        logger.info("å¯åŠ¨ V3 æ™ºèƒ½ç­–ç•¥æœºå™¨äºº (Probability/Fair Value)...")
        logger.info(f"é…ç½®: æ­¢æŸçº¿ -{self.stop_loss_pct*100}% | æ¨¡æ‹Ÿè´¹ç‡ {self.fee_pct*100}%")
        if self.paper_trade: logger.info("[æ¨¡å¼] æ¨¡æ‹Ÿäº¤æ˜“ (å…¨æƒé™æ‰˜ç®¡)")
        while self.running:
            try:
                # Run Auto-Tuning every cycle
                self.analyze_performance()
                # Cleanup old positions from previous cycles
                self.positions = [p for p in self.positions if (datetime.now(timezone.utc) - datetime.fromisoformat(p["timestamp"])).total_seconds() < 3600]
                market = self.cycle_manager.fetch_market()
                if not market:
                    logger.info("ç­‰å¾…æ´»è·ƒå¸‚åœº...")
                    await asyncio.sleep(10)
                    continue
                # Fetch Strike Price (Open Price)
                # Ensure the market start time has passed so the candle exists
                now = datetime.now(timezone.utc)
                if now < market.start_time:
                    logger.info(f"ç­‰å¾…å¸‚åœºå¼€å§‹: {market.start_time}")
                    await asyncio.sleep(5)
                    continue
                logger.info(f"é€‰ä¸­å¸‚åœº: {market.question}")
                # Get Strike Price (Binance)
                # Need timestamp in ms
                start_ts_ms = int(market.start_time.timestamp() * 1000)
                # Retry fetching strike until available (Binance might delay 1-2s)
                strike_price = None
                for _ in range(5):
                    strike_price = BinanceData.get_candle_open(start_ts_ms)
                    if strike_price: break
                    logger.info("ç­‰å¾… Strike Price (Binance Candle)...")
                    await asyncio.sleep(2)
                if not strike_price:
                    logger.error("æ— æ³•è·å– Strike Priceï¼Œè·³è¿‡æ­¤å‘¨æœŸ")
                    await asyncio.sleep(30)
                    continue
                market.strike_price = strike_price
                logger.info(f"ğŸ¯ Strike Price (é”å®š): ${strike_price:,.2f}")
                # Start Trading Loop for this Market
                await self.trade_loop(market)
            except Exception as e:
                logger.error(f"Main loop error: {e}")
                await asyncio.sleep(5)
    async def trade_loop(self, market: Market15m):
        # WebSocket would go here (simplified for V3 POC to polling for clarity, can add WS back)
        # For brevity in this write, using polling loop which is fine for 5s intervals.
        # Ideally keep WS from V2.
        ws_manager = WebSocketManagerV3(market)
        await ws_manager.connect()
        asyncio.create_task(ws_manager.listen())
        logger.info(f"å¼€å§‹ç›‘æ§... ç»“ç®—æ—¶é—´: {market.end_time}")
        while self.running and market.is_active:
            # 1. Get Data
            current_btc = BinanceData.get_current_price()
            if not current_btc:
                await asyncio.sleep(2)
                continue
            time_left = market.time_remaining.total_seconds() / 60.0 # minutes
            # 2. Calculate Fair Value
            prob_up = self.strategy.calculate_prob_up(current_btc, market.strike_price, time_left)
            prob_down = 1.0 - prob_up
            # 3. AI Prediction Boost
            if self.ml_model:
                try:
                    hour = datetime.now(timezone.utc).hour
                    # Simple prediction based on market structure
                    # If AI predicts WIN for UP, we boost prob_up
                    # Warning: This is a simplified integration
                    X = [[market.up_price, 1, hour]]
                    if self.ml_model.predict(X)[0] == 1:
                        prob_up += 0.05
                except: pass
            # 3. Compare with Market
            # Market prices from WS
            mkt_up = market.up_price
            mkt_down = market.down_price
            # 4. Decision
            # Calculate dynamic Safety Margin to account for Binance vs Chainlink deviation
            # using percentage (0.05%) instead of fixed amount
            safety_margin = market.strike_price * self.safety_margin_pct
            diff = current_btc - market.strike_price
            # Check Stop Loss for existing positions
            await self.check_stop_loss(market)
            # If within safety margin (ambiguous zone), force neutral probability or skip
            if abs(diff) < safety_margin:
                logger.info(f"ä»·æ ¼å·®å¼‚ ${diff:.1f} åœ¨å®‰å…¨è¾¹é™…(${safety_margin:.1f}, {self.safety_margin_pct:.2%})å†… - è·³è¿‡")
                await asyncio.sleep(2)
                continue
            # Only trade if we don't have a position in this market yet (Simple mode)
            has_position = any(p['market_slug'] == market.slug for p in self.positions)
            if not has_position and abs(diff) >= safety_margin:
                # Signal if Edge > Threshold
                edge_up = prob_up - mkt_up
                edge_down = prob_down - mkt_down
                log_msg = (
                    f"å‰©ä½™ {time_left:.1f}m | BTC: ${current_btc:.1f} (Diff: ${diff:+.1f}) | "
                    f"Prob UP: {prob_up:.1%} vs Mkt: {mkt_up:.1%} (Edge: {edge_up:+.1%})"
                )
                # Only log every 10s
                if int(time.time()) % 10 == 0:
                    logger.info(log_msg)
                # Execute Trade
                if edge_up > self.min_edge: 
                    await self.execute_trade(market, "UP", 0.05)
                elif edge_down > self.min_edge:
                    await self.execute_trade(market, "DOWN", 0.05)
            elif int(time.time()) % 10 == 0:
                 logger.info(f"ç›‘æ§ä¸­... æŒä»“æ•°: {len(self.positions)} | ä»·æ ¼å·®: ${diff:+.1f}")
            await asyncio.sleep(2)
        await ws_manager.close()
        # MARKET SETTLEMENT (Simulated)
        # Fetch Final Price (Binance Candle Open of the NEXT candle, or just current price if immediate)
        # To be precise: The resolution price is typically the price AT expiration.
        await asyncio.sleep(5) # Wait for dust to settle
        final_price = BinanceData.get_current_price()
        if final_price:
            logger.info(f"å¸‚åœºç»“ç®—! Final BTC: ${final_price}")
            await self.settle_positions(market, final_price)
    async def settle_positions(self, market, final_price):
        """Settle open positions for paper trading"""
        if not self.paper_trade: return
        strike = market.strike_price
        if not strike: return
        # Determine Winner
        # "Up" if Final >= Strike
        winner = "UP" if final_price >= strike else "DOWN"
        logger.info(f"ğŸ† ç»“ç®—ç»“æœ: {winner} (Strike: {strike} vs Final: {final_price})")
        # Iterate remaining positions for this market
        for p in list(self.positions):
            if p["market_slug"] != market.slug: continue
            payout = 1.0 if p["direction"] == winner else 0.0
            pnl_amt = payout - p["entry_price"]
            pnl_pct = pnl_amt / p["entry_price"]
            logger.info(f"ğŸ’° ç»“ç®—å½’æ¡£: {p['direction']} -> PnL: {pnl_pct:.1%}")
            with open("paper_trades.jsonl", "a") as f:
                f.write(json.dumps({
                    "time": datetime.now(timezone.utc).isoformat(),
                    "type": "SETTLED",
                    "market": market.slug,
                    "direction": p["direction"],
                    "entry_price": p["entry_price"],
                    "exit_price": payout, # 1.0 or 0.0
                    "pnl": pnl_pct,
                    "result": "WIN" if payout > 0 else "LOSS"
                }) + "\n")
            self.positions.remove(p)
    async def check_stop_loss(self, market: Market15m):
        """Check if any position needs to be stopped out"""
        # Copy list to modify safe
        for p in list(self.positions):
            if p["market_slug"] != market.slug: continue
            current_price = market.up_price if p["direction"] == "UP" else market.down_price
            entry_price = p["entry_price"]
            # PnL calculation
            pnl_pct = (current_price - entry_price) / entry_price
            if pnl_pct < -self.stop_loss_pct:
                logger.warning(f"ğŸ›‘ æ­¢æŸè§¦å‘! {p['direction']} @ {current_price:.2f} (Entry: {entry_price:.2f}, PnL: {pnl_pct:.1%})")
                if self.paper_trade:
                    with open("paper_trades.jsonl", "a") as f:
                        f.write(json.dumps({
                            "time": datetime.now(timezone.utc).isoformat(),
                            "type": "STOP_LOSS",
                            "market": market.slug,
                            "direction": p["direction"],
                            "exit_price": current_price,
                            "pnl": pnl_pct
                        }) + "\n")
                else:
                    # Real sell logic would go here
                    pass
                self.positions.remove(p)
    async def execute_trade(self, market, direction, size):
        # Simple limit order logic
        price = market.up_price if direction == "UP" else market.down_price
        # Cap price
        price = min(0.99, max(0.01, price))
        if self.paper_trade:
             logger.info(f"ğŸ”¥ SIGNAL: BUY {direction} @ {price:.2f} (Paper Trade)")
             # Record Position
             self.positions.append({
                 "market_slug": market.slug,
                 "direction": direction,
                 "entry_price": price,
                 "size": size,
                 "timestamp": datetime.now(timezone.utc).isoformat()
             })
             with open("paper_trades.jsonl", "a") as f:
                 f.write(json.dumps({
                     "time": datetime.now().isoformat(),
                     "type": "V3_SMART",
                     "direction": direction,
                     "price": price,
                     "strike": market.strike_price,
                     "fee": self.fee_pct # Record fee assumption
                 }) + "\n")
             await asyncio.sleep(10) # Cooldown
        else:
            # Real execution code here
            pass
# --- Reusing WebSocket Manager from V2 for compactness ---
class WebSocketManagerV3:
    def __init__(self, market):
        self.market = market
        self.ws = None
        self.running = False
    async def connect(self):
        self.ws = await websockets.connect(WS_URL)
        msg = {"assets_ids": [self.market.token_id_up, self.market.token_id_down], "type": "market"}
        await self.ws.send(json.dumps(msg))
        self.running = True
    async def listen(self):
        try:
            async for msg in self.ws:
                if not self.running: break
                if msg == "PONG": continue
                try:
                    data = json.loads(msg)
                    if isinstance(data, list): [self._process(i) for i in data]
                    else: self._process(data)
                except: pass
        except: pass
    def _process(self, data):
        asset = data.get("asset_id")
        if asset == self.market.token_id_up: self.market.book_up.update(data)
        elif asset == self.market.token_id_down: self.market.book_down.update(data)
        elif data.get("event_type") == "price_change":
            for p in data.get("price_changes", []):
                aid = p.get("asset_id")
                if aid == self.market.token_id_up: self.market.book_up.best_ask = float(p.get("best_ask") or 1)
                elif aid == self.market.token_id_down: self.market.book_down.best_ask = float(p.get("best_ask") or 1)
    async def close(self):
        self.running = False
        if self.ws: await self.ws.close()
if __name__ == "__main__":
    asyncio.run(PolymarketBotV3().run())
</file>

<file path="check_account.py">
#!/usr/bin/env python3
"""æ£€æŸ¥è´¦æˆ·è¿æ¥å’Œä½™é¢"""
import os
from dotenv import load_dotenv
from py_clob_client.client import ClobClient
load_dotenv()
CLOB_HOST = "https://clob.polymarket.com"
CHAIN_ID = 137
def main():
    private_key = os.getenv("PRIVATE_KEY")
    funder = os.getenv("FUNDER_ADDRESS")
    print("=" * 50)
    print("Polymarket è´¦æˆ·æ£€æŸ¥")
    print("=" * 50)
    print(f"Funder åœ°å€: {funder}")
    print(f"ç§é’¥: {private_key[:8]}...{private_key[-4:]}")
    print()
    # åˆå§‹åŒ–å®¢æˆ·ç«¯
    print("åˆå§‹åŒ– CLOB å®¢æˆ·ç«¯...")
    client = ClobClient(
        CLOB_HOST,
        key=private_key,
        chain_id=CHAIN_ID,
        signature_type=2,  # Proxy wallet
        funder=funder
    )
    # åˆ›å»º/è·å– API å‡­æ®
    print("è·å– API å‡­æ®...")
    creds = client.create_or_derive_api_creds()
    client.set_api_creds(creds)
    print(f"  âœ“ API Key: {creds.api_key[:16]}...")
    # æµ‹è¯•è¿æ¥
    print("\næµ‹è¯• API è¿æ¥...")
    ok = client.get_ok()
    print(f"  âœ“ CLOB OK: {ok}")
    # è·å–ä½™é¢ï¼ˆå¦‚æœAPIæ”¯æŒï¼‰
    print("\nå°è¯•è·å–è´¦æˆ·ä¿¡æ¯...")
    try:
        # å°è¯•è·å–å¼€æ”¾è®¢å•
        orders = client.get_orders()
        print(f"  âœ“ å½“å‰å¼€æ”¾è®¢å•: {len(orders) if orders else 0}")
    except Exception as e:
        print(f"  (æ— æ³•è·å–è®¢å•: {e})")
    print("\n" + "=" * 50)
    print("âœ“ è´¦æˆ·è¿æ¥æˆåŠŸï¼å‡†å¤‡å°±ç»ªã€‚")
    print("=" * 50)
if __name__ == "__main__":
    main()
</file>

<file path="check_balance.py">
#!/usr/bin/env python3
"""æ£€æŸ¥ Polymarket é’±åŒ…ä½™é¢"""
import os
import requests
from dotenv import load_dotenv
load_dotenv()
funder = os.getenv("FUNDER_ADDRESS")
print(f"æ£€æŸ¥é’±åŒ…: {funder}\n")
# 1. é€šè¿‡ Data API è·å–ç”¨æˆ·æŒä»“
print("=" * 40)
print("æŒä»“ä¿¡æ¯")
print("=" * 40)
try:
    resp = requests.get(
        f"https://data-api.polymarket.com/positions",
        params={"user": funder.lower()},
        timeout=15
    )
    positions = resp.json()
    print(f"æŒä»“æ•°é‡: {len(positions)}")
    for p in positions[:10]:
        market = p.get('market', {})
        print(f"  â€¢ {market.get('question', 'Unknown')[:60]}")
        print(f"    æ•°é‡: {p.get('size', 0)}, æ–¹å‘: {p.get('outcome', 'N/A')}")
except Exception as e:
    print(f"è·å–æŒä»“å¤±è´¥: {e}")
# 2. Polygon USDC ä½™é¢
print("\n" + "=" * 40)
print("Polygon é“¾ä¸Šä½™é¢")
print("=" * 40)
# USDC.e on Polygon (bridged USDC)
USDC_E = "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174"
# Native USDC on Polygon
USDC_NATIVE = "0x3c499c542cEF5E3811e1192ce70d8cC03d5c3359"
for name, contract in [("USDC.e", USDC_E), ("USDC", USDC_NATIVE)]:
    try:
        resp = requests.get(
            "https://api.polygonscan.com/api",
            params={
                "module": "account",
                "action": "tokenbalance",
                "contractaddress": contract,
                "address": funder,
                "tag": "latest"
            },
            timeout=10
        )
        data = resp.json()
        if data.get("status") == "1":
            balance_wei = int(data.get("result", 0))
            balance = balance_wei / 1e6
            print(f"{name}: ${balance:,.2f}")
    except Exception as e:
        print(f"{name}: æŸ¥è¯¢å¤±è´¥ - {e}")
# MATIC
try:
    resp = requests.get(
        "https://api.polygonscan.com/api",
        params={
            "module": "account",
            "action": "balance",
            "address": funder,
            "tag": "latest"
        },
        timeout=10
    )
    data = resp.json()
    if data.get("status") == "1":
        balance_wei = int(data.get("result", 0))
        balance = balance_wei / 1e18
        print(f"MATIC: {balance:.4f}")
except Exception as e:
    print(f"MATIC: æŸ¥è¯¢å¤±è´¥ - {e}")
# 3. æ£€æŸ¥ Polymarket äº¤æ˜“å†å²
print("\n" + "=" * 40)
print("æœ€è¿‘äº¤æ˜“")
print("=" * 40)
try:
    resp = requests.get(
        f"https://data-api.polymarket.com/activity",
        params={"user": funder.lower(), "limit": 5},
        timeout=15
    )
    activities = resp.json()
    if activities:
        for a in activities[:5]:
            print(f"  â€¢ {a.get('type', 'Unknown')}: {a.get('market', {}).get('question', '')[:40]}")
    else:
        print("  (æ— äº¤æ˜“è®°å½•)")
except Exception as e:
    print(f"è·å–äº¤æ˜“å†å²å¤±è´¥: {e}")
print("\n" + "=" * 40)
</file>

<file path="check_prev_market.py">
import requests
import json
from datetime import datetime
# 18:30 UTC timestamp was 1769538600
# So previous market (18:15 UTC) start timestamp was 1769537700
slug_prev = "btc-updown-15m-1769537700"
GAMMA_API = "https://gamma-api.polymarket.com"
def check_prev_market():
    resp = requests.get(f"{GAMMA_API}/events", params={"slug": slug_prev})
    if resp.status_code == 200:
        data = resp.json()
        if data:
            # Look for resolution details in the markets
            m = data[0].get("markets", [])[0]
            print(json.dumps(m, indent=2))
        else:
            print("No data for prev market")
check_prev_market()
</file>

<file path="fetch_history.py">
import requests
import json
import time
from datetime import datetime, timezone, timedelta
GAMMA_API = "https://gamma-api.polymarket.com"
# Fetch past 24h of BTC 15m markets
# We need to reconstruct the "slugs" or just search by tag/series
# Series slug: "btc-up-or-down-15m" (From previous inspect)
def fetch_historical_markets():
    print("Fetching historical markets from Gamma API...")
    # Calculate timestamps for the last 24h (96 markets)
    now = int(time.time())
    start_ts = now - 86400
    # Align to 15m
    start_ts = (start_ts // 900) * 900
    markets_data = []
    for ts in range(start_ts, now, 900):
        slug = f"btc-updown-15m-{ts}"
        try:
            resp = requests.get(f"{GAMMA_API}/events?slug={slug}", timeout=5)
            data = resp.json()
            if not data:
                print(f"Skipping {slug} (No data)")
                continue
            event = data[0]
            market = event.get("markets", [])[0]
            # We need: Strike Price, End Price (Resolution), and Result
            # Strike Price is not explicitly in API, but it's the Open Price of the candle at StartTime
            # We will fetch that from Binance later.
            # Result: "outcomePrices": "[\"1\", \"0\"]" -> UP won
            prices = json.loads(market.get("outcomePrices", '["0.5", "0.5"]'))
            winner = "UP" if prices[0] == "1" else "DOWN" if prices[1] == "1" else "UNKNOWN"
            if winner == "UNKNOWN": continue
            start_time_iso = event.get("startDate") # 2026-01-27T18:30:00Z
            markets_data.append({
                "ts": ts,
                "start_time": start_time_iso,
                "winner": winner,
                "slug": slug
            })
            print(f"Found: {slug} -> {winner}")
            time.sleep(0.1) # Rate limit nice
        except Exception as e:
            print(f"Error fetching {slug}: {e}")
    return markets_data
def enrich_with_binance(markets):
    print("\nEnriching with Binance OHLCV data...")
    enriched = []
    for m in markets:
        ts_ms = m["ts"] * 1000
        # Get candle at start time (Strike)
        # And candle at end time (Resolution) - roughly +15m
        try:
            # Get Strike (Open of start candle)
            url = "https://api.binance.com/api/v3/klines"
            # 1. Strike Price
            params = {"symbol": "BTCUSDT", "interval": "1m", "startTime": ts_ms, "limit": 1}
            resp = requests.get(url, params=params, timeout=5)
            kline_start = resp.json()
            strike = float(kline_start[0][1]) # Open
            # 2. Volatility / Trend Feature (Previous 15m candle)
            # Get the candle BEFORE this market started to calculate trend
            params_prev = {"symbol": "BTCUSDT", "interval": "15m", "startTime": ts_ms - 900000, "limit": 1}
            resp_prev = requests.get(url, params=params_prev, timeout=5)
            kline_prev = resp_prev.json()
            prev_open = float(kline_prev[0][1])
            prev_close = float(kline_prev[0][4])
            trend_pct = (prev_close - prev_open) / prev_open
            m["strike_price"] = strike
            m["prev_trend"] = trend_pct
            enriched.append(m)
            print(f"Enriched {m['slug']}: Strike {strike}, Trend {trend_pct:.4%}")
            time.sleep(0.1)
        except Exception as e:
            print(f"Binance error for {m['slug']}: {e}")
    return enriched
def save_to_training_data(data):
    # Convert to format compatible with training script
    # We need to simulate "trades". 
    # Since we know the winner, we can generate synthetic "Winning Trades" to teach the model WHAT WINS.
    print(f"\nGenerating synthetic training data from {len(data)} markets...")
    with open("polymarket-bot/paper_trades.jsonl", "a") as f:
        for m in data:
            # Synthetic Trade: If UP won, we simulate a "BUY UP" trade that won.
            # We want the model to learn to predict the WINNER.
            record = {
                "time": m["start_time"],
                "type": "SETTLED", # Mark as settled for training
                "market": m["slug"],
                "direction": m["winner"], # The winning direction
                "entry_price": 0.50, # Assume avg entry
                "exit_price": 1.0,
                "pnl": 1.0, # Dummy positive PnL
                "result": "WIN",
                # Extra features for ML
                "strike_price": m["strike_price"],
                "prev_trend": m["prev_trend"]
            }
            f.write(json.dumps(record) + "\n")
    print("âœ… Successfully appended historical data to paper_trades.jsonl")
if __name__ == "__main__":
    markets = fetch_historical_markets()
    if markets:
        enriched = enrich_with_binance(markets)
        save_to_training_data(enriched)
</file>

<file path="gemini_trader.py">
import os
import google.generativeai as genai
from google.generativeai import caching
import datetime
import logging
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
from google.api_core import exceptions
logger = logging.getLogger(__name__)
class GeminiTraderAI:
    def __init__(self, api_key=None, model_name='models/gemini-1.5-flash-001'):
        self.api_key = api_key or os.getenv("GEMINI_API_KEY")
        genai.configure(api_key=self.api_key)
        self.model_name = model_name
        self.cache = None
    @retry(
        retry=retry_if_exception_type((exceptions.ResourceExhausted, exceptions.ServiceUnavailable)),
        wait=wait_exponential(multiplier=1, min=4, max=60),
        stop=stop_after_attempt(5)
    )
    def update_knowledge_base(self, history_text):
        """Cache large historical data to avoid 429s and save costs"""
        try:
            # Cleanup old session caches
            for c in caching.CachedContent.list():
                if c.display_name == "trader_knowledge":
                    c.delete()
            self.cache = caching.CachedContent.create(
                model=self.model_name,
                display_name="trader_knowledge",
                system_instruction="You are an expert Quant Trader. Analyze history to optimize the current BTC 15m strategy.",
                contents=[history_text],
                ttl=datetime.timedelta(minutes=65),
            )
            logger.info(f"âœ… Context Cache Updated: {self.cache.name}")
            return True
        except Exception as e:
            logger.error(f"âŒ Failed to update cache: {e}")
            return False
    @retry(
        retry=retry_if_exception_type(exceptions.ResourceExhausted),
        wait=wait_exponential(multiplier=1, min=2, max=10),
        stop=stop_after_attempt(3)
    )
    def get_decision(self, prompt):
        """Get trading decision using cached context"""
        if not self.cache:
            # Fallback to no cache if not initialized
            model = genai.GenerativeModel(self.model_name)
            return model.generate_content(prompt).text
        model = genai.GenerativeModel.from_cached_content(cached_content=self.cache)
        response = model.generate_content(prompt)
        return response.text
</file>

<file path="inspect_market.py">
import requests
import json
GAMMA_API = "https://gamma-api.polymarket.com"
def check_market():
    # Fetch a recent BTC market slug to inspect structure
    slug = "btc-updown-15m-1769538600" # From previous log
    # Or just search
    resp = requests.get(f"{GAMMA_API}/events", params={"slug": slug})
    if resp.status_code == 200:
        data = resp.json()
        if data:
            print(json.dumps(data[0], indent=2))
        else:
            print("No data found for slug")
check_market()
</file>

<file path="polymarket-bot.service">
[Unit]
Description=Polymarket BTC 15m Trading Bot
After=network.target

[Service]
Type=simple
User=ubuntu
WorkingDirectory=/home/ubuntu/clawd/polymarket-bot
ExecStart=/home/ubuntu/clawd/polymarket-bot/venv/bin/python btc_15m_bot_v3.py
Restart=always
RestartSec=10
Environment=PYTHONUNBUFFERED=1

[Install]
WantedBy=multi-user.target
</file>

<file path="README.md">
# Polymarket BTC 15-Minute Trading Bot v2

è‡ªåŠ¨äº¤æ˜“ Polymarket ä¸Šçš„æ¯”ç‰¹å¸15åˆ†é’Ÿæ¶¨è·Œé¢„æµ‹å¸‚åœºã€‚

## åŠŸèƒ½

- ğŸ”Œ **WebSocket å®æ—¶è®¢é˜…** - è®¢å•ç°¿å®æ—¶æ›´æ–°ï¼Œä¸æ˜¯è½®è¯¢
- ğŸ”„ **è‡ªåŠ¨å‘¨æœŸåˆ‡æ¢** - ä¸€ä¸ª15åˆ†é’Ÿå¸‚åœºç»“æŸåè‡ªåŠ¨è¿›å…¥ä¸‹ä¸€ä¸ª
- ğŸ” è‡ªåŠ¨ç›‘æ§ BTC 15åˆ†é’Ÿå¸‚åœº
- ğŸ“Š å¤šç­–ç•¥æ”¯æŒï¼ˆåŠ¨é‡ã€èµ”ç‡ä»·å€¼ï¼‰
- âš ï¸ é£é™©ç®¡ç†ï¼ˆå•ç¬”ä¸Šé™ã€æ—¥äºæŸé™åˆ¶ï¼‰
- ğŸ“ äº¤æ˜“æ—¥å¿—
- ğŸ” 24å°æ—¶è‡ªåŠ¨è¿è¡Œ

## å®‰è£…

```bash
cd polymarket-bot
source venv/bin/activate  # æ¿€æ´»è™šæ‹Ÿç¯å¢ƒ
```

## é…ç½®

1. å¤åˆ¶é…ç½®æ–‡ä»¶ï¼š
```bash
cp .env.example .env
```

2. ç¼–è¾‘ `.env`ï¼Œå¡«å…¥ï¼š
- `PRIVATE_KEY` - ä½ çš„é’±åŒ…ç§é’¥ï¼ˆä¸å¸¦0xå‰ç¼€ï¼‰
- `FUNDER_ADDRESS` - æŒæœ‰èµ„é‡‘çš„åœ°å€

## ä½¿ç”¨

æµ‹è¯•è¿æ¥ï¼š
```bash
python test_connection.py
```

**v1 ç‰ˆæœ¬**ï¼ˆç®€å•è½®è¯¢ï¼‰ï¼š
```bash
python btc_15m_bot.py
```

**v2 ç‰ˆæœ¬**ï¼ˆWebSocket + è‡ªåŠ¨å‘¨æœŸï¼‰ï¼š
```bash
python btc_15m_bot_v2.py
```

## 24å°æ—¶åå°è¿è¡Œ

æ–¹æ³•1 - nohupï¼š
```bash
nohup python btc_15m_bot_v2.py > bot.log 2>&1 &
```

æ–¹æ³•2 - systemd æœåŠ¡ï¼š
```bash
sudo cp polymarket-bot.service /etc/systemd/system/
sudo systemctl daemon-reload
sudo systemctl enable polymarket-bot
sudo systemctl start polymarket-bot

# æŸ¥çœ‹çŠ¶æ€
sudo systemctl status polymarket-bot

# æŸ¥çœ‹æ—¥å¿—
journalctl -u polymarket-bot -f
```

## ç­–ç•¥è¯´æ˜

- **momentum** - è·Ÿéšè¶‹åŠ¿ï¼ŒBTC 5åˆ†é’Ÿå†…æ¶¨è¶…0.1%å°±ä¹°UPï¼Œè·Œå°±ä¹°DOWN
- **odds_value** - å¯»æ‰¾å®šä»·åå·®ï¼Œå¦‚æœ UP ä»·æ ¼ä½äº 45% å°±ä¹°ï¼ˆç†è®ºä¸Šåº”è¯¥æ˜¯50/50ï¼‰

## æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CoinGecko API  â”‚â”€â”€â”€â”€â”€â–¶â”‚  Price Tracker   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Polymarket WSS  â”‚â”€â”€â”€â”€â”€â–¶â”‚  Order Book      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Gamma API      â”‚â”€â”€â”€â”€â”€â–¶â”‚ Cycle Manager    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚   Strategy       â”‚
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚
                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚   CLOB Client    â”‚â”€â”€â–¶ ä¸‹å•
                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## é£é™©æç¤º

âš ï¸ è¿™æ˜¯å®éªŒæ€§è½¯ä»¶ï¼Œå¯èƒ½äºæŸã€‚åªæŠ•å…¥ä½ èƒ½æ‰¿å—æŸå¤±çš„èµ„é‡‘ã€‚
</file>

<file path="repomix.config.json">
{
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "removeComments": false,
    "removeEmptyLines": true
  },
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": [
      "*.jsonl",
      "*.log",
      "venv/",
      "__pycache__/",
      "*.pkl",
      "paper_trades_*.jsonl"
    ]
  }
}
</file>

<file path="test_connection.py">
#!/usr/bin/env python3
"""
Test Polymarket API connection and find BTC markets (no auth needed)
"""
import requests
from py_clob_client.client import ClobClient
CLOB_HOST = "https://clob.polymarket.com"
GAMMA_API = "https://gamma-api.polymarket.com"
def test_clob_connection():
    """Test basic CLOB connection"""
    print("Testing CLOB API...")
    client = ClobClient(CLOB_HOST)  # Read-only, no auth
    ok = client.get_ok()
    server_time = client.get_server_time()
    print(f"  âœ“ CLOB OK: {ok}")
    print(f"  âœ“ Server time: {server_time}")
    return True
def find_btc_markets():
    """Find active BTC 15-min markets"""
    print("\nSearching for BTC 15-minute markets...")
    resp = requests.get(
        f"{GAMMA_API}/markets",
        params={
            "active": "true",
            "closed": "false",
            "limit": 200
        },
        timeout=15
    )
    resp.raise_for_status()
    markets = resp.json()
    btc_markets = []
    for market in markets:
        question = market.get("question", "").lower()
        if "bitcoin" in question and ("15" in question or "15m" in question):
            btc_markets.append(market)
    if btc_markets:
        print(f"  âœ“ Found {len(btc_markets)} BTC market(s):")
        for m in btc_markets[:3]:  # Show first 3
            print(f"    - {m.get('question', 'Unknown')}")
            print(f"      Prices: {m.get('outcomePrices', 'N/A')}")
            print(f"      Volume: ${float(m.get('volume', 0)):,.2f}")
            print(f"      End: {m.get('endDate', 'N/A')}")
    else:
        print("  âš  No active BTC 15-min markets found right now")
        print("    (They might be between intervals)")
    return btc_markets
def get_btc_price():
    """Get current BTC price"""
    print("\nGetting BTC price...")
    resp = requests.get(
        "https://api.coingecko.com/api/v3/simple/price",
        params={"ids": "bitcoin", "vs_currencies": "usd"},
        timeout=10
    )
    resp.raise_for_status()
    price = resp.json()["bitcoin"]["usd"]
    print(f"  âœ“ BTC/USD: ${price:,.2f}")
    return price
def main():
    print("=" * 50)
    print("Polymarket BTC Bot - Connection Test")
    print("=" * 50)
    try:
        test_clob_connection()
        get_btc_price()
        find_btc_markets()
        print("\n" + "=" * 50)
        print("âœ“ All tests passed! Ready to trade.")
        print("=" * 50)
    except Exception as e:
        print(f"\nâœ— Error: {e}")
        return 1
    return 0
if __name__ == "__main__":
    exit(main())
</file>

<file path="test_order.py">
#!/usr/bin/env python3
"""æµ‹è¯•ä¸‹å•å’Œæ’¤å•ç³»ç»Ÿ"""
import os
import json
import time
import requests
from datetime import datetime, timezone
from dotenv import load_dotenv
from py_clob_client.client import ClobClient
from py_clob_client.clob_types import OrderArgs, OrderType
from py_clob_client.order_builder.constants import BUY
load_dotenv()
CLOB_HOST = "https://clob.polymarket.com"
GAMMA_API = "https://gamma-api.polymarket.com"
CHAIN_ID = 137
def get_current_market():
    """è·å–å½“å‰æ´»è·ƒçš„ BTC 15åˆ†é’Ÿå¸‚åœº"""
    now = datetime.now(timezone.utc)
    current_ts = int(now.timestamp())
    # å½“å‰å’Œä¸‹ä¸€ä¸ªå‘¨æœŸ
    for offset in [0, 900]:
        ts = ((current_ts // 900) * 900) + offset
        slug = f"btc-updown-15m-{ts}"
        try:
            resp = requests.get(f"{GAMMA_API}/events?slug={slug}", timeout=10)
            events = resp.json()
            if events and not events[0].get("closed", True):
                event = events[0]
                markets = event.get("markets", [])
                if markets and markets[0].get("acceptingOrders", False):
                    market = markets[0]
                    token_ids = json.loads(market.get("clobTokenIds", "[]"))
                    outcomes = json.loads(market.get("outcomes", '["Up", "Down"]'))
                    # ç¡®å®š UP token
                    if outcomes[0].lower() == "up":
                        token_up = token_ids[0]
                    else:
                        token_up = token_ids[1]
                    return {
                        "title": event.get("title", ""),
                        "end": market.get("endDate", ""),
                        "token_id": token_up,
                        "condition_id": market.get("conditionId", "")
                    }
        except Exception as e:
            print(f"æŸ¥è¯¢ {slug} å¤±è´¥: {e}")
    return None
def main():
    print("=" * 60)
    print("Polymarket ä¸‹å•/æ’¤å•æµ‹è¯•")
    print("=" * 60)
    # åˆå§‹åŒ–å®¢æˆ·ç«¯
    private_key = os.getenv("PRIVATE_KEY")
    funder = os.getenv("FUNDER_ADDRESS")
    print(f"\né’±åŒ…: {funder[:10]}...{funder[-6:]}")
    client = ClobClient(
        CLOB_HOST,
        key=private_key,
        chain_id=CHAIN_ID,
        signature_type=2,  # Proxy wallet
        funder=funder
    )
    client.set_api_creds(client.create_or_derive_api_creds())
    print("âœ“ å®¢æˆ·ç«¯åˆå§‹åŒ–æˆåŠŸ")
    # è·å–å½“å‰å¸‚åœº
    print("\næŸ¥æ‰¾æ´»è·ƒå¸‚åœº...")
    market = get_current_market()
    if not market:
        print("âœ— æ²¡æœ‰æ‰¾åˆ°æ´»è·ƒçš„ BTC 15åˆ†é’Ÿå¸‚åœº")
        print("  å¯èƒ½åœ¨å‘¨æœŸåˆ‡æ¢ä¸­ï¼Œè¯·ç¨åå†è¯•")
        return
    print(f"âœ“ æ‰¾åˆ°å¸‚åœº: {market['title']}")
    print(f"  ç»“æŸæ—¶é—´: {market['end']}")
    print(f"  Token ID: {market['token_id'][:20]}...")
    # æŸ¥çœ‹å½“å‰è®¢å•
    print("\nå½“å‰å¼€æ”¾è®¢å•:")
    try:
        orders = client.get_orders()
        print(f"  è®¢å•æ•°: {len(orders) if orders else 0}")
        if orders:
            for o in orders[:3]:
                print(f"    - {o}")
    except Exception as e:
        print(f"  è·å–è®¢å•å¤±è´¥: {e}")
    # ä¸‹é™ä»·å• @ $0.01
    print("\n" + "-" * 40)
    print("æµ‹è¯•ä¸‹å•: BUY UP @ $0.01, æ•°é‡ 5 shares")
    print("-" * 40)
    try:
        order = OrderArgs(
            token_id=market["token_id"],
            price=0.01,  # æœ€ä½ä»·æ ¼
            size=5.0,    # æœ€å°æ•°é‡
            side=BUY
        )
        signed_order = client.create_order(order)
        print(f"âœ“ è®¢å•å·²ç­¾å")
        resp = client.post_order(signed_order, OrderType.GTC)
        print(f"âœ“ è®¢å•å·²æäº¤!")
        print(f"  å“åº”: {resp}")
        order_id = resp.get("orderID") or resp.get("order_id") or resp.get("id")
        if order_id:
            print(f"\nè®¢å• ID: {order_id}")
            # ç­‰å¾…ä¸€ä¸‹
            time.sleep(2)
            # æŸ¥çœ‹è®¢å•çŠ¶æ€
            print("\næ£€æŸ¥è®¢å•çŠ¶æ€...")
            orders = client.get_orders()
            found = False
            for o in orders or []:
                if str(o.get("id")) == str(order_id) or str(o.get("order_id")) == str(order_id):
                    print(f"  âœ“ è®¢å•åœ¨åˆ—è¡¨ä¸­")
                    found = True
                    break
            if not found and orders:
                print(f"  è®¢å•åˆ—è¡¨: {[o.get('id') for o in orders[:5]]}")
            # æ’¤å•
            print("\n" + "-" * 40)
            print("æµ‹è¯•æ’¤å•...")
            print("-" * 40)
            try:
                cancel_resp = client.cancel(order_id=order_id)
                print(f"âœ“ æ’¤å•æˆåŠŸ!")
                print(f"  å“åº”: {cancel_resp}")
            except Exception as e:
                print(f"âœ— æ’¤å•å¤±è´¥: {e}")
                # å°è¯•å–æ¶ˆæ‰€æœ‰è®¢å•
                print("\nå°è¯•å–æ¶ˆæ‰€æœ‰è®¢å•...")
                try:
                    cancel_all = client.cancel_all()
                    print(f"âœ“ å–æ¶ˆæ‰€æœ‰è®¢å•: {cancel_all}")
                except Exception as e2:
                    print(f"âœ— å–æ¶ˆæ‰€æœ‰å¤±è´¥: {e2}")
        else:
            print(f"  æ— æ³•è·å–è®¢å• IDï¼Œå“åº”: {resp}")
    except Exception as e:
        print(f"âœ— ä¸‹å•å¤±è´¥: {e}")
        # å¦‚æœæ˜¯ä½™é¢é—®é¢˜ï¼Œç»™å‡ºå»ºè®®
        if "balance" in str(e).lower() or "allowance" in str(e).lower():
            print("\nå»ºè®®: ä½™é¢ä¸è¶³æˆ–æœªæˆæƒ")
            print("  1. åœ¨ Polymarket ç½‘ç«™å­˜å…¥æ›´å¤š USDC")
            print("  2. æˆ–è€…åœ¨ç½‘ç«™ä¸Šæ‰‹åŠ¨ä¸‹ä¸€ç¬”å•æ¿€æ´»æˆæƒ")
    # æœ€åæ£€æŸ¥è®¢å•
    print("\n" + "=" * 60)
    print("æœ€ç»ˆè®¢å•çŠ¶æ€:")
    try:
        final_orders = client.get_orders()
        print(f"  å¼€æ”¾è®¢å•æ•°: {len(final_orders) if final_orders else 0}")
    except Exception as e:
        print(f"  è·å–å¤±è´¥: {e}")
    print("=" * 60)
    print("æµ‹è¯•å®Œæˆ")
if __name__ == "__main__":
    main()
</file>

<file path="train_ml.py">
#!/usr/bin/env python3
"""
Polymarket Machine Learning Training Script
- Reads paper_trades.jsonl (historical data)
- Trains a Random Forest Classifier to predict WIN/LOSS
- Saves the model to be used by V4 bot
"""
import json
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report
import joblib
import os
DATA_FILE = "polymarket-bot/paper_trades.jsonl"
MODEL_FILE = "polymarket-bot/ml_model_v1.pkl"
def load_data():
    if not os.path.exists(DATA_FILE):
        print(f"No data file found at {DATA_FILE}")
        return None
    data = []
    with open(DATA_FILE, "r") as f:
        for line in f:
            try:
                record = json.loads(line)
                # We only want SETTLED records which have a result
                if record.get("type") == "SETTLED":
                    data.append(record)
            except:
                pass
    if not data:
        print("No settled trades found to train on.")
        return None
    df = pd.DataFrame(data)
    return df
def feature_engineering(df):
    """
    Convert raw trade data into ML features
    Target: 1 if WIN, 0 if LOSS
    """
    # Create target variable
    df['target'] = df['result'].apply(lambda x: 1 if x == 'WIN' else 0)
    # Features to use:
    # 1. Entry Price (Cost basis) - Lower usually means better odds?
    # 2. Direction (Encoded: UP=1, DOWN=0)
    # 3. Hour of day (Maybe some hours are better?)
    df['direction_code'] = df['direction'].apply(lambda x: 1 if x == 'UP' else 0)
    # Parse timestamp
    df['datetime'] = pd.to_datetime(df['time'])
    df['hour'] = df['datetime'].dt.hour
    # Select features for training
    features = ['entry_price', 'direction_code', 'hour']
    X = df[features]
    y = df['target']
    return X, y
def train_model():
    print("Loading data...")
    df = load_data()
    if df is None: return
    print(f"Found {len(df)} settled trades.")
    if len(df) < 10:
        print("âš ï¸ Data insufficient for ML training (need >10 trades).")
        print("Please let V3 bot run longer to accumulate data.")
        return
    print("Engineering features...")
    X, y = feature_engineering(df)
    # Split
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    print("Training Random Forest Classifier...")
    clf = RandomForestClassifier(n_estimators=100, random_state=42)
    clf.fit(X_train, y_train)
    # Evaluate
    y_pred = clf.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    print(f"\nğŸ¯ Model Accuracy: {accuracy:.2%}")
    print("\nClassification Report:")
    print(classification_report(y_test, y_pred))
    # Save
    print(f"Saving model to {MODEL_FILE}...")
    joblib.dump(clf, MODEL_FILE)
    print("âœ… Done.")
if __name__ == "__main__":
    train_model()
</file>

</files>
